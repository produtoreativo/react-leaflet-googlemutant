{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 607c27eb86fb56e5064a","webpack:///external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}","webpack:///./src/react-leaflet-googlemutant/googleapiloader.js","webpack:///./src/react-leaflet-googlemutant/googlemutant.js","webpack:///./src/react-leaflet-googlemutant/index.js","webpack:///./~/leaflet.gridlayer.googlemutant/Leaflet.GoogleMutant.js","webpack:///external {\"commonjs2\":\"leaflet\",\"commonjs\":\"leaflet\",\"amd\":\"leaflet\"}","webpack:///external {\"commonjs2\":\"react-leaflet\",\"commonjs\":\"react-leaflet\",\"amd\":\"react-leaflet\"}","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"names":["GoogleApiLoader","state","googleLoaded","url","version","client","language","region","channel","libraries","callback","children","afterLoad","setState","createUrl","signature","apiKey","chave","assinatura","libs","length","join","cliente","canal","lang","regiao","load","window","script","document","createElement","type","src","onload","body","appendChild","props","Component","propTypes","PropTypes","element","isRequired","string","arrayOf","oneOf","GoogleMutant","process","config","layer","L","gridLayer","googleMutant","addGoogleLayer","MapLayer","default"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,GAAG;;AAEH;AACA;AACA,wBAAwB,eAAe;AACvC,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA,0BAA0B,iCAAiC;AAC3D,EAAE;;AAEF;AACA,iBAAiB,sBAAsB;AACvC;AACA,kBAAkB,gCAAgC;AAClD;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4C;AACA,2CAA2C,iCAAiC;AAC5E,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;;AAGF;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,uBAAuB;AACtC;AACA,kC;AACA;AACA;;AAEA,qD;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;;;;;;;ACxbA,+C;;;;;;ACAA,+C;;;;;;ACAA,+C","file":"react-leaflet-googlemutant.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"prop-types\"), require(\"leaflet\"), require(\"react-leaflet\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"prop-types\", \"leaflet\", \"react-leaflet\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactLeafletGoogleMutant\"] = factory(require(\"prop-types\"), require(\"leaflet\"), require(\"react-leaflet\"), require(\"react\"));\n\telse\n\t\troot[\"ReactLeafletGoogleMutant\"] = factory(root[\"PropTypes\"], root[undefined], root[undefined], root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 607c27eb86fb56e5064a","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}\n// module id = 0\n// module chunks = 0","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass GoogleApiLoader extends Component {\n\n  static propTypes = {\n    children: PropTypes.element.isRequired,\n    apiKey: PropTypes.string,\n    libraries: PropTypes.arrayOf(\n      PropTypes.oneOf([\n        'drawing',\n        'geometry',\n        'places',\n        'visualization',\n        'directions',\n      ])\n    ),\n  }\n\n  state = {\n    googleLoaded: false,\n    url: 'https://maps.googleapis.com/maps/api/js',\n    version: '3.27',\n    client: null,\n    language: null,\n    region: null,\n    channel: null,\n    libraries: [],\n    callback: '__google_maps_api_provider_initializator__',\n    children: null,\n  }\n\n  componentWillMount() {\n    this.setState({\n      ...this.state,\n      ...this.props,\n    });\n  }\n\n  componentDidMount() {\n    if (!this.state.googleLoaded) {\n      this.load();\n    }\n  }\n\n  afterLoad = () => {\n    this.setState({\n      ...this.state,\n      googleLoaded: true,\n    });\n  }\n\n  createUrl = () => {\n    const {\n      url,\n      callback,\n      libraries,\n      client,\n      version,\n      channel,\n      language,\n      region,\n      signature,\n      apiKey,\n    } = this.state;\n    const chave = apiKey ? `&key=${apiKey}` : '';\n    const assinatura = signature ? `&signature=${signature}` : '';\n    const libs = libraries.length ? `&libraries=${libraries.join(',')}` : '';\n    const cliente = client ? `&client=${client}&v=${version}` : '';\n    const canal = channel ? `&channel=${channel}` : '';\n    const lang = language ? `&language=${language}`: '';\n    const regiao = region ? `&region=${region}`: '';\n    return `${url}?callback=${callback}${assinatura}${chave}${libs}${cliente}${canal}${lang}${regiao}`;\n  }\n\n  load = () => {\n    const { callback } = this.state;\n    if (!window[callback]) {\n      window[callback] = () => {};\n    }\n    const script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = this.createUrl();\n    script.onload = this.afterLoad;\n    document.body.appendChild(script);\n  }\n\n  render() {\n    const { googleLoaded } = this.state;\n    const { children } = this.props;\n    if (!googleLoaded) {\n      return null;\n    }\n    return children;\n  }\n}\n\nexport default GoogleApiLoader;\n\n\n\n// WEBPACK FOOTER //\n// ./src/react-leaflet-googlemutant/googleapiloader.js","import PropTypes from 'prop-types';\nimport L from 'leaflet';\nimport 'leaflet.gridlayer.googlemutant';\nimport { MapLayer } from 'react-leaflet';\n\nexport default class GoogleMutant extends MapLayer {\n\n  static propTypes = {\n    type: PropTypes.oneOf(['hybrid', 'roadmap', 'satellite', 'terrain']),\n    layer: PropTypes.oneOf(['TrafficLayer', 'TransitLayer'])\n  }\n\n  version = process.env.__VERSION__\n\n  createLeafletElement(props) {\n    const config = { type: 'roadmap', ...props };\n    const layer = new L.gridLayer.googleMutant(config);\n    if (props.layer) {\n      layer.addGoogleLayer(props.layer)\n    }\n    return layer;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/react-leaflet-googlemutant/googlemutant.js","export { default as GoogleApiLoader} from 'react-leaflet-googlemutant/googleapiloader.js';\nexport { default as GoogleMutant } from 'react-leaflet-googlemutant/googlemutant.js';\n\n\n\n// WEBPACK FOOTER //\n// ./src/react-leaflet-googlemutant/index.js","// Based on https://github.com/shramov/leaflet-plugins\n// GridLayer like https://avinmathew.com/leaflet-and-google-maps/ , but using MutationObserver instead of jQuery\n\n\n// 🍂class GridLayer.GoogleMutant\n// 🍂extends GridLayer\nL.GridLayer.GoogleMutant = L.GridLayer.extend({\n\toptions: {\n\t\tminZoom: 0,\n\t\tmaxZoom: 23,\n\t\ttileSize: 256,\n\t\tsubdomains: 'abc',\n\t\terrorTileUrl: '',\n\t\tattribution: '',\t// The mutant container will add its own attribution anyways.\n\t\topacity: 1,\n\t\tcontinuousWorld: false,\n\t\tnoWrap: false,\n\t\t// 🍂option type: String = 'roadmap'\n\t\t// Google's map type. Valid values are 'roadmap', 'satellite' or 'terrain'. 'hybrid' is not really supported.\n\t\ttype: 'roadmap',\n\t\tmaxNativeZoom: 21\n\t},\n\n\tinitialize: function (options) {\n\t\tL.GridLayer.prototype.initialize.call(this, options);\n\n\t\tthis._ready = !!window.google && !!window.google.maps && !!window.google.maps.Map;\n\n\t\tthis._GAPIPromise = this._ready ? Promise.resolve(window.google) : new Promise(function (resolve, reject) {\n\t\t\tvar checkCounter = 0;\n\t\t\tvar intervalId = null;\n\t\t\tintervalId = setInterval(function () {\n\t\t\t\tif (checkCounter >= 10) {\n\t\t\t\t\tclearInterval(intervalId);\n\t\t\t\t\treturn reject(new Error('window.google not found after 10 attempts'));\n\t\t\t\t}\n\t\t\t\tif (!!window.google && !!window.google.maps && !!window.google.maps.Map) {\n\t\t\t\t\tclearInterval(intervalId);\n\t\t\t\t\treturn resolve(window.google);\n\t\t\t\t}\n\t\t\t\tcheckCounter++;\n\t\t\t}, 500);\n\t\t});\n\n\t\t// Couple data structures indexed by tile key\n\t\tthis._tileCallbacks = {};\t// Callbacks for promises for tiles that are expected\n\t\tthis._freshTiles = {};\t// Tiles from the mutant which haven't been requested yet\n\n\t\tthis._imagesPerTile = (this.options.type === 'hybrid') ? 2 : 1;\n\t},\n\n\tonAdd: function (map) {\n\t\tL.GridLayer.prototype.onAdd.call(this, map);\n\t\tthis._initMutantContainer();\n\n\t\tthis._GAPIPromise.then(function () {\n\t\t\tthis._ready = true;\n\t\t\tthis._map = map;\n\n\t\t\tthis._initMutant();\n\n\t\t\tmap.on('viewreset', this._reset, this);\n\t\t\tmap.on('move', this._update, this);\n\t\t\tmap.on('zoomend', this._handleZoomAnim, this);\n\t\t\tmap.on('resize', this._resize, this);\n\n\t\t\t//handle layer being added to a map for which there are no Google tiles at the given zoom\n\t\t\tgoogle.maps.event.addListenerOnce(this._mutant, 'idle', function () {\n\t\t\t\tthis._checkZoomLevels();\n\t\t\t\tthis._mutantIsReady = true;\n\t\t\t}.bind(this));\n\n\t\t\t//20px instead of 1em to avoid a slight overlap with google's attribution\n\t\t\tmap._controlCorners.bottomright.style.marginBottom = '20px';\n\t\t\tmap._controlCorners.bottomleft.style.marginBottom = '20px';\n\n\t\t\tthis._reset();\n\t\t\tthis._update();\n\n\t\t\tif (this._subLayers) {\n\t\t\t\t//restore previously added google layers\n\t\t\t\tfor (var layerName in this._subLayers) {\n\t\t\t\t\tthis._subLayers[layerName].setMap(this._mutant);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\t},\n\n\tonRemove: function (map) {\n\t\tL.GridLayer.prototype.onRemove.call(this, map);\n\t\tmap._container.removeChild(this._mutantContainer);\n\t\tthis._mutantContainer = undefined;\n\n\t\tgoogle.maps.event.clearListeners(map, 'idle');\n\t\tgoogle.maps.event.clearListeners(this._mutant, 'idle');\n\t\tmap.off('viewreset', this._reset, this);\n\t\tmap.off('move', this._update, this);\n\t\tmap.off('zoomend', this._handleZoomAnim, this);\n\t\tmap.off('resize', this._resize, this);\n\n\t\tif (map._controlCorners) {\n\t\t\tmap._controlCorners.bottomright.style.marginBottom = '0em';\n\t\t\tmap._controlCorners.bottomleft.style.marginBottom = '0em';\n\t\t}\n\t},\n\n\tgetAttribution: function () {\n\t\treturn this.options.attribution;\n\t},\n\n\tsetOpacity: function (opacity) {\n\t\tthis.options.opacity = opacity;\n\t\tif (opacity < 1) {\n\t\t\tL.DomUtil.setOpacity(this._mutantContainer, opacity);\n\t\t}\n\t},\n\n\tsetElementSize: function (e, size) {\n\t\te.style.width = size.x + 'px';\n\t\te.style.height = size.y + 'px';\n\t},\n\n\n\taddGoogleLayer: function (googleLayerName, options) {\n\t\tif (!this._subLayers) this._subLayers = {};\n\t\treturn this._GAPIPromise.then(function () {\n\t\t\tvar Constructor = google.maps[googleLayerName];\n\t\t\tvar googleLayer = new Constructor(options);\n\t\t\tgoogleLayer.setMap(this._mutant);\n\t\t\tthis._subLayers[googleLayerName] = googleLayer;\n\t\t\treturn googleLayer;\n\t\t}.bind(this));\n\t},\n\n\tremoveGoogleLayer: function (googleLayerName) {\n\t\tvar googleLayer = this._subLayers && this._subLayers[googleLayerName];\n\t\tif (!googleLayer) return;\n\n\t\tgoogleLayer.setMap(null);\n\t\tdelete this._subLayers[googleLayerName];\n\t},\n\n\n\t_initMutantContainer: function () {\n\t\tif (!this._mutantContainer) {\n\t\t\tthis._mutantContainer = L.DomUtil.create('div', 'leaflet-google-mutant leaflet-top leaflet-left');\n\t\t\tthis._mutantContainer.id = '_MutantContainer_' + L.Util.stamp(this._mutantContainer);\n\t\t\tthis._mutantContainer.style.zIndex = '800'; //leaflet map pane at 400, controls at 1000\n\t\t\tthis._mutantContainer.style.pointerEvents = 'none';\n\n\t\t\tthis._map.getContainer().appendChild(this._mutantContainer);\n\t\t}\n\n\t\tthis.setOpacity(this.options.opacity);\n\t\tthis.setElementSize(this._mutantContainer, this._map.getSize());\n\n\t\tthis._attachObserver(this._mutantContainer);\n\t},\n\n\t_initMutant: function () {\n\t\tif (!this._ready || !this._mutantContainer) return;\n\t\tthis._mutantCenter = new google.maps.LatLng(0, 0);\n\n\t\tvar map = new google.maps.Map(this._mutantContainer, {\n\t\t\tcenter: this._mutantCenter,\n\t\t\tzoom: 0,\n\t\t\ttilt: 0,\n\t\t\tmapTypeId: this.options.type,\n\t\t\tdisableDefaultUI: true,\n\t\t\tkeyboardShortcuts: false,\n\t\t\tdraggable: false,\n\t\t\tdisableDoubleClickZoom: true,\n\t\t\tscrollwheel: false,\n\t\t\tstreetViewControl: false,\n\t\t\tstyles: this.options.styles || {},\n\t\t\tbackgroundColor: 'transparent'\n\t\t});\n\n\t\tthis._mutant = map;\n\n\t\tgoogle.maps.event.addListenerOnce(map, 'idle', function () {\n\t\t\tvar nodes = this._mutantContainer.querySelectorAll('a');\n\t\t\tfor (var i = 0; i < nodes.length; i++) {\n\t\t\t\tnodes[i].style.pointerEvents = 'auto';\n\t\t\t}\n\t\t}.bind(this));\n\n\t\t// 🍂event spawned\n\t\t// Fired when the mutant has been created.\n\t\tthis.fire('spawned', {mapObject: map});\n\t},\n\n\t_attachObserver: function _attachObserver (node) {\n// \t\tconsole.log('Gonna observe', node);\n\n\t\tvar observer = new MutationObserver(this._onMutations.bind(this));\n\n\t\t// pass in the target node, as well as the observer options\n\t\tobserver.observe(node, { childList: true, subtree: true });\n\t},\n\n\t_onMutations: function _onMutations (mutations) {\n\t\tfor (var i = 0; i < mutations.length; ++i) {\n\t\t\tvar mutation = mutations[i];\n\t\t\tfor (var j = 0; j < mutation.addedNodes.length; ++j) {\n\t\t\t\tvar node = mutation.addedNodes[j];\n\n\t\t\t\tif (node instanceof HTMLImageElement) {\n\t\t\t\t\tthis._onMutatedImage(node);\n\t\t\t\t} else if (node instanceof HTMLElement) {\n\t\t\t\t\tArray.prototype.forEach.call(node.querySelectorAll('img'), this._onMutatedImage.bind(this));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Only images which 'src' attrib match this will be considered for moving around.\n\t// Looks like some kind of string-based protobuf, maybe??\n\t// Only the roads (and terrain, and vector-based stuff) match this pattern\n\t_roadRegexp: /!1i(\\d+)!2i(\\d+)!3i(\\d+)!/,\n\n\t// On the other hand, raster imagery matches this other pattern\n\t_satRegexp: /x=(\\d+)&y=(\\d+)&z=(\\d+)/,\n\n\t// On small viewports, when zooming in/out, a static image is requested\n\t// This will not be moved around, just removed from the DOM.\n\t_staticRegExp: /StaticMapService\\.GetMapImage/,\n\n\t_onMutatedImage: function _onMutatedImage (imgNode) {\n// \t\tif (imgNode.src) {\n// \t\t\tconsole.log('caught mutated image: ', imgNode.src);\n// \t\t}\n\n\t\tvar coords;\n\t\tvar match = imgNode.src.match(this._roadRegexp);\n\t\tvar sublayer = 0;\n\n\t\tif (match) {\n\t\t\tcoords = {\n\t\t\t\tz: match[1],\n\t\t\t\tx: match[2],\n\t\t\t\ty: match[3]\n\t\t\t};\n\t\t\tif (this._imagesPerTile > 1) { \n\t\t\t\timgNode.style.zIndex = 1;\n\t\t\t\tsublayer = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tmatch = imgNode.src.match(this._satRegexp);\n\t\t\tif (match) {\n\t\t\t\tcoords = {\n\t\t\t\t\tx: match[1],\n\t\t\t\t\ty: match[2],\n\t\t\t\t\tz: match[3]\n\t\t\t\t};\n\t\t\t}\n// \t\t\timgNode.style.zIndex = 0;\n\t\t\tsublayer = 0;\n\t\t}\n\n\t\tif (coords) {\n\t\t\tvar tileKey = this._tileCoordsToKey(coords);\n\t\t\timgNode.style.position = 'absolute';\n\t\t\timgNode.style.visibility = 'hidden';\n\n\t\t\tvar key = tileKey + '/' + sublayer;\n\t\t\t// console.log('mutation for tile', key)\n\t\t\t//store img so it can also be used in subsequent tile requests\n\t\t\tthis._freshTiles[key] = imgNode;\n\n\t\t\tif (key in this._tileCallbacks && this._tileCallbacks[key]) {\n// console.log('Fullfilling callback ', key);\n\t\t\t\t//fullfill most recent tileCallback because there maybe callbacks that will never get a \n\t\t\t\t//corresponding mutation (because map moved to quickly...)\n\t\t\t\tthis._tileCallbacks[key].pop()(imgNode); \n\t\t\t\tif (!this._tileCallbacks[key].length) { delete this._tileCallbacks[key]; }\n\t\t\t} else {\n\t\t\t\tif (this._tiles[tileKey]) {\n\t\t\t\t\t//we already have a tile in this position (mutation is probably a google layer being added)\n\t\t\t\t\t//replace it\n\t\t\t\t\tvar c = this._tiles[tileKey].el;\n\t\t\t\t\tvar oldImg = (sublayer === 0) ? c.firstChild : c.firstChild.nextSibling;\n\t\t\t\t\tvar cloneImgNode = this._clone(imgNode);\n\t\t\t\t\tc.replaceChild(cloneImgNode, oldImg);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (imgNode.src.match(this._staticRegExp)) {\n\t\t\timgNode.style.visibility = 'hidden';\n\t\t}\n\t},\n\n\n\tcreateTile: function (coords, done) {\n\t\tvar key = this._tileCoordsToKey(coords);\n\n\t\tvar tileContainer = L.DomUtil.create('div');\n\t\ttileContainer.dataset.pending = this._imagesPerTile;\n\t\tdone = done.bind(this, null, tileContainer);\n\n\t\tfor (var i = 0; i < this._imagesPerTile; i++) {\n\t\t\tvar key2 = key + '/' + i;\n\t\t\tif (key2 in this._freshTiles) {\n\t\t\t\tvar imgNode = this._freshTiles[key2];\n\t\t\t\ttileContainer.appendChild(this._clone(imgNode));\n\t\t\t\ttileContainer.dataset.pending--;\n// \t\t\t\tconsole.log('Got ', key2, ' from _freshTiles');\n\t\t\t} else {\n\t\t\t\tthis._tileCallbacks[key2] = this._tileCallbacks[key2] || [];\n\t\t\t\tthis._tileCallbacks[key2].push( (function (c/*, k2*/) {\n\t\t\t\t\treturn function (imgNode) {\n\t\t\t\t\t\tc.appendChild(this._clone(imgNode));\n\t\t\t\t\t\tc.dataset.pending--;\n\t\t\t\t\t\tif (!parseInt(c.dataset.pending)) { done(); }\n// \t\t\t\t\t\tconsole.log('Sent ', k2, ' to _tileCallbacks, still ', c.dataset.pending, ' images to go');\n\t\t\t\t\t}.bind(this);\n\t\t\t\t}.bind(this))(tileContainer/*, key2*/) );\n\t\t\t}\n\t\t}\n\n\t\tif (!parseInt(tileContainer.dataset.pending)) {\n\t\t\tL.Util.requestAnimFrame(done);\n\t\t}\n\t\treturn tileContainer;\n\t},\n\n\t_clone: function (imgNode) {\n\t\tvar clonedImgNode = imgNode.cloneNode(true);\n\t\tclonedImgNode.style.visibility = 'visible';\n\t\treturn clonedImgNode;\n\t},\n\n\t_checkZoomLevels: function () {\n\t\t//setting the zoom level on the Google map may result in a different zoom level than the one requested\n\t\t//(it won't go beyond the level for which they have data).\n\t\tvar zoomLevel = this._map.getZoom();\n\t\tvar gMapZoomLevel = this._mutant.getZoom();\n\t\tif (!zoomLevel || !gMapZoomLevel) return;\n\n\n\t\tif ((gMapZoomLevel !== zoomLevel) || //zoom levels are out of sync, Google doesn't have data\n\t\t\t(gMapZoomLevel > this.options.maxNativeZoom)) { //at current location, Google does have data (contrary to maxNativeZoom)\n\t\t\t//Update maxNativeZoom\n\t\t\tthis._setMaxNativeZoom(gMapZoomLevel);\n\t\t}\n\t},\n\n\t_setMaxNativeZoom: function (zoomLevel) {\n\t\tif (zoomLevel != this.options.maxNativeZoom) {\n\t\t\tthis.options.maxNativeZoom = zoomLevel;\n\t\t\tthis._resetView();\n\t\t}\n\t},\n\n\t_reset: function () {\n\t\tthis._initContainer();\n\t},\n\n\t_update: function () {\n\t\t// zoom level check needs to happen before super's implementation (tile addition/creation)\n\t\t// otherwise tiles may be missed if maxNativeZoom is not yet correctly determined\n\t\tif (this._mutant) {\n\t\t\tvar center = this._map.getCenter();\n\t\t\tvar _center = new google.maps.LatLng(center.lat, center.lng);\n\n\t\t\tthis._mutant.setCenter(_center);\n\t\t\tvar zoom = this._map.getZoom();\n\t\t\tvar fractionalLevel = zoom !== Math.round(zoom);\n\t\t\tvar mutantZoom = this._mutant.getZoom();\n\n\t\t\t//ignore fractional zoom levels\n\t\t\tif (!fractionalLevel && (zoom != mutantZoom)) {\n\t\t\t\tthis._mutant.setZoom(zoom);\n\t\t\t\t\t\t\t\n\t\t\t\tif (this._mutantIsReady) this._checkZoomLevels();\n\t\t\t\t//else zoom level check will be done later by 'idle' handler\n\t\t\t}\n\t\t}\n\n\t\tL.GridLayer.prototype._update.call(this);\n\t},\n\n\t_resize: function () {\n\t\tvar size = this._map.getSize();\n\t\tif (this._mutantContainer.style.width === size.x &&\n\t\t\tthis._mutantContainer.style.height === size.y)\n\t\t\treturn;\n\t\tthis.setElementSize(this._mutantContainer, size);\n\t\tif (!this._mutant) return;\n\t\tgoogle.maps.event.trigger(this._mutant, 'resize');\n\t},\n\n\t_handleZoomAnim: function () {\n\t\tif (!this._mutant) return;\n\t\tvar center = this._map.getCenter();\n\t\tvar _center = new google.maps.LatLng(center.lat, center.lng);\n\n\t\tthis._mutant.setCenter(_center);\n\t\tthis._mutant.setZoom(Math.round(this._map.getZoom()));\n\t},\n\n\t// Agressively prune _freshtiles when a tile with the same key is removed,\n\t// this prevents a problem where Leaflet keeps a loaded tile longer than\n\t// GMaps, so that GMaps makes two requests but Leaflet only consumes one,\n\t// polluting _freshTiles with stale data.\n\t_removeTile: function (key) {\n\t\tif (!this._mutant) return;\n\n\t\t//give time for animations to finish before checking it tile should be pruned\n\t\tsetTimeout(this._pruneTile.bind(this, key), 1000);\n\n\n\t\treturn L.GridLayer.prototype._removeTile.call(this, key);\n\t},\n\n\t_pruneTile: function (key) {\n\t\tvar gZoom = this._mutant.getZoom();\n\t\tvar tileZoom = key.split(':')[2];\n\t\tvar googleBounds = this._mutant.getBounds();\n\t\tvar sw = googleBounds.getSouthWest();\n\t\tvar ne = googleBounds.getNorthEast();\n\t\tvar gMapBounds = L.latLngBounds([[sw.lat(), sw.lng()], [ne.lat(), ne.lng()]]);\n\n\t\tfor (var i=0; i<this._imagesPerTile; i++) {\n\t\t\tvar key2 = key + '/' + i;\n\t\t\tif (key2 in this._freshTiles) { \n\t\t\t\tvar tileBounds = this._map && this._keyToBounds(key);\n\t\t\t\tvar stillVisible = this._map && tileBounds.overlaps(gMapBounds) && (tileZoom == gZoom);\n\n\t\t\t\tif (!stillVisible) delete this._freshTiles[key2]; \n//\t\t\t\tconsole.log('Prunning of ', key, (!stillVisible))\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n// 🍂factory gridLayer.googleMutant(options)\n// Returns a new `GridLayer.GoogleMutant` given its options\nL.gridLayer.googleMutant = function (options) {\n\treturn new L.GridLayer.GoogleMutant(options);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/leaflet.gridlayer.googlemutant/Leaflet.GoogleMutant.js\n// module id = 4\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs2\":\"leaflet\",\"commonjs\":\"leaflet\",\"amd\":\"leaflet\"}\n// module id = 5\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs2\":\"react-leaflet\",\"commonjs\":\"react-leaflet\",\"amd\":\"react-leaflet\"}\n// module id = 6\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 7\n// module chunks = 0"],"sourceRoot":""}